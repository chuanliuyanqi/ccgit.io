<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>50种语言"我爱你"爱心环绕</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas"></canvas>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');
        
        // 高DPI屏幕适配
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            
            // 开启高质量渲染
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }

        // 初始化画布
        setupCanvas();

        // 50种语言的"我爱你"
        const loveTexts = [
            "我爱你", "我中意你", "我爱侬", "我欢喜你", "勾买蒙", "额爱你",
            "I love you", "Je t'aime", "Ich liebe dich", "Ti amo", "Te amo",
            "あいしてる", "사랑해", "أحبك", "Σ'αγαπώ", "Ik hou van jou", 
            "Jag älskar dig", "Jeg elsker deg", "Rwy'n dy garu di", "Mahal kita",
            "Szeretlek", "Volim te", "Miluji tě", "Kocham Cię", "Te iubesc",
            "Ljubim te", "Mina armastan sind", "Es mīlu tevi", "Aš tave myliu",
            "Обіжаю тебе", "Te dua", "Seni seviyorum", "Mən səni sevirəm",
            "მიყვარხარ", "Men seni süyemin", "ฉันรักคุณ", "Tôi yêu bạn",
            "Nakupenda", "Wo ie ni", "Ke a go rata", "Ndinokuda",
            "Mena urang beungeut", "Të dua", "Mwen renmen ou", "Is breá liom tú",
            "Tha gràdh agam ort", "Ek het jou lief", "Ina sonki", "Ngiyakuthanda",
            "Ke a lo rata", "Ndimakukonda"
        ];

        // 颜色数组
        const colors = [
            "#FFB6C1", "#FF69B4", "#FF1493", "#FFC0CB", "#DB7093",
            "#FF6B9D", "#FF8DA1", "#FFA7B6", "#FFC4D6", "#FFDDE6",
            "#FF7EB3", "#FF66B2", "#FF3399", "#FF0080", "#CC0066"
        ];

        // 生成爱心形状点（轨道不显示）
        function generateHeartPoints(count) {
            const points = [];
            const centerX = (canvas.width / window.devicePixelRatio) / 2;
            const centerY = (canvas.height / window.devicePixelRatio) / 2;
            const size = Math.min(
                canvas.width / window.devicePixelRatio, 
                canvas.height / window.devicePixelRatio
            ) * 0.3;
            
            for (let i = 0; i < count; i++) {
                const t = (i / count) * 2 * Math.PI;
                // 爱心参数方程
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // 计算每个点的切线角度（用于文字朝向）
                const angle = Math.atan2(
                    -(-13 * Math.sin(t) + 10 * Math.sin(2*t) + 6 * Math.sin(3*t) + 4 * Math.sin(4*t)),
                    48 * Math.pow(Math.sin(t), 2) * Math.cos(t)
                );
                
                points.push({
                    x: centerX + x * size / 16,
                    y: centerY - y * size / 16,
                    angle: angle // 保存角度用于文字朝向校正
                });
            }
            return points;
        }

        // 创建文字对象
        const textObjects = [];
        let heartPoints = generateHeartPoints(1500); // 爱心轨道点（不显示）
        let mouse = { x: 0, y: 0, active: false };
        let isMovingForward = true; // 控制文字移动方向

        // 基础速度调整为原来的2/3
        const baseSpeed = (window.innerWidth < 768 ? 0.15 : 0.20) * (2/3);

        for (let i = 0; i < loveTexts.length; i++) {
            const startIndex = Math.floor(i * heartPoints.length / loveTexts.length);
            
            textObjects.push({
                text: loveTexts[i],
                color: colors[i % colors.length],
                size: (window.innerWidth < 768 ? 12 : 16) + Math.random() * 6,
                currentIndex: startIndex,
                speed: baseSpeed + (Math.random() * 0.06 - 0.03), // 微小速度差异
                subPixelX: 0,
                subPixelY: 0,
                targetX: 0,
                targetY: 0,
                targetAngle: 0, // 目标角度，用于文字朝向
                pulse: 0.8 + Math.random() * 0.4,
                originalSize: 0
            });
        }

        // 初始化原始大小
        textObjects.forEach(obj => {
            obj.originalSize = obj.size;
        });

        // 预计算字体
        function preloadFonts() {
            textObjects.forEach(obj => {
                ctx.font = `bold ${obj.size}px Arial`;
                ctx.measureText(obj.text);
            });
        }

        preloadFonts();

        // 绘制函数
        function draw() {
            // 清除画布
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, w, h);
            
            // 更新和绘制所有文字
            textObjects.forEach(obj => {
                // 根据方向更新位置
                const speed = isMovingForward ? obj.speed : -obj.speed;
                obj.currentIndex = (obj.currentIndex + speed + heartPoints.length) % heartPoints.length;
                
                // 获取当前和目标点
                const currentIndex = Math.floor(obj.currentIndex);
                const nextIndex = (currentIndex + 1) % heartPoints.length;
                const fraction = obj.currentIndex - currentIndex;
                
                const currentPoint = heartPoints[currentIndex];
                const nextPoint = heartPoints[nextIndex];
                
                // 线性插值实现更平滑的移动
                obj.targetX = currentPoint.x + (nextPoint.x - currentPoint.x) * fraction;
                obj.targetY = currentPoint.y + (nextPoint.y - currentPoint.y) * fraction;
                obj.targetAngle = currentPoint.angle + (nextPoint.angle - currentPoint.angle) * fraction;
                
                // 鼠标交互 - 排斥效果
                if (mouse.active) {
                    const dx = obj.targetX - mouse.x;
                    const dy = obj.targetY - mouse.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 80) {
                        const repel = (80 - dist) / 80 * 15;
                        const angle = Math.atan2(dy, dx);
                        obj.targetX += Math.cos(angle) * repel;
                        obj.targetY += Math.sin(angle) * repel;
                    }
                }
                
                // 缓动效果
                const easing = 0.12;
                obj.subPixelX += (obj.targetX - obj.subPixelX) * easing;
                obj.subPixelY += (obj.targetY - obj.subPixelY) * easing;
                
                // 脉冲效果
                obj.size = obj.originalSize * (1 + Math.sin(Date.now() * 0.0015 * obj.pulse) * 0.15);
                
                // 绘制文字 - 确保文字不会倒转
                ctx.save();
                
                // 将坐标系原点移动到文字位置
                ctx.translate(obj.subPixelX, obj.subPixelY);
                
                // 校正角度确保文字始终正立
                let textAngle = obj.targetAngle;
                
                // 关键修正：确保文字不会倒转
                // 检测角度是否会导致文字倒置，必要时翻转180度
                if (textAngle > Math.PI/2 && textAngle < 3*Math.PI/2) {
                    textAngle += Math.PI;
                }
                
                ctx.rotate(textAngle);
                
                ctx.fillStyle = obj.color;
                ctx.font = `bold ${obj.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 发光效果
                ctx.shadowColor = obj.color;
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // 绘制文字
                ctx.fillText(obj.text, 0, 0);
                
                ctx.restore();
            });
        }

        // 动画循环
        function animate(currentTime) {
            // 只有页面可见时才绘制
            if (document.visibilityState === 'visible') {
                draw();
            }
            
            requestAnimationFrame(animate);
        }

        // 启动动画
        requestAnimationFrame(animate);

        // 事件监听 - 鼠标移动
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse = {
                x: (e.clientX - rect.left),
                y: (e.clientY - rect.top),
                active: true
            };
        });

        // 事件监听 - 触摸移动
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouse = {
                x: (touch.clientX - rect.left),
                y: (touch.clientY - rect.top),
                active: true
            };
        }, { passive: false });

        // 事件监听 - 鼠标离开
        canvas.addEventListener('mouseleave', () => {
            mouse.active = false;
        });

        // 事件监听 - 触摸结束
        canvas.addEventListener('touchend', () => {
            mouse.active = false;
        });

        // 事件监听 - 点击切换方向
        canvas.addEventListener('click', () => {
            isMovingForward = !isMovingForward;
        });

        // 窗口大小变化时重置
        window.addEventListener('resize', () => {
            const dpr = window.devicePixelRatio || 1;
            const oldRatio = textObjects.length > 0 
                ? textObjects[0].currentIndex / heartPoints.length 
                : 0;
            
            setupCanvas();
            
            // 重新生成爱心点并保持文字相对位置
            const newHeartPoints = generateHeartPoints(1500);
            textObjects.forEach(obj => {
                obj.currentIndex = Math.floor(oldRatio * newHeartPoints.length);
            });
            
            heartPoints = newHeartPoints;
        });
    </script>
</body>
</html>